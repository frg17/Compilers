%{
  import java.io.*;
%}

%token <sval> OPNAME, WHILE, LITERAL, IF, ELSIF, ELSE, RETURN, NAME,OPNAME_AND, OPNAME_OR, OPNAME_NOT, OPNAME1, OPNAME2, OPNAME3 ,OPNAME4, OPNAME5, OPNAME6, OPNAME7, VAR
%type <obj> program, function, args, declarations, decl, expressions, expr, binopexpr, binopexpr1, binopexpr2, binopexpr3, binopexpr4, binopexpr5, binopexpr6, binopexpr7, op, orexpr, andexpr, notexpr, smallexpr, ifexpr, elsif, else, body, names
%left OPNAME1, OPNAME3, OPNAME4, OPNAME5, OPNAME6, OPNAME7
%right OPNAME2

%%

start : program { generateProgram(nanoMorpho, ((Vector<Object>)($1)).toArray()); }
      ;



program : program function {((Vector<Object>)($1)).add($2); $$ = $1}
        | function {$$ = new Vector<Object>(); ((Vector<Object>)($$)).add($1); }
        ;



function :
          {
            varCount = 0;
            varTable = new HashMap<String, Integer>();
          }
           NAME '(' names ')' '{' declarations expressions '}' {$$ = new Object[]{$2, $4, $7, $8}; }
         ;



names : names ',' NAME  {addVar($3); $$ = $1 + 1}
     | NAME      {addVar($1); $$ = $1 + 1}
     |           {$$ = 0}
     ;


declarations : VAR decl ';' declarations { $$ = $3 + 1; }
             |                       { $$ = 0; }
             ;



decl : decl ',' Name{ addVar($2); }
     | NAME     { addVar($2); }
     ;



expressions : expr ';' expressions { (Vector<Object>)($$).add($1) }
            |                      { $$ = new Vector<Object>(); }
            ;



expr : RETURN orexpr  { $$ = new Object[]{"RETURN", $2}; }
     | NAME '=' expr  { $$ = new Object[]{"STORE", findVar($1), $3}; }
     | orexpr         { $$ = $1; }
     ;



orexpr : andexpr OPNAME_OR orexpr { $$ = new Object[]{"OR", $1, $3}; }
       | andexpr                  { $$ = $1; }
       ;

      

andexpr : notexpr OPNAME_AND andexpr {$$ = new Object[]{"AND", $1, $3}; }
        | notexpr                    {$$ = $1; }
        ;



notexpr : OPNAME_NOT notexpr { $$ = new Object[]{"NOT", $2}; }
        | binopexpr          { $$ = $1; }
        ;


/*
binopexpr1 : binopexpr1 OPNAME1 binopexpr2
           | binopexpr2




binopexpr2 : binopexpr3 OPNAME2 binopexpr2
           | binopexpr3 
           ;



binopexpr3 : binopexpr3 OPNAME3 binopexpr4
           | binopexpr4
           ;




binopexpr4 : binopexpr4 OPNAME4 binopexpr5
           | binopexpr5
           ;




binopexpr5 : binopexpr5 OPNAME5 binopexpr6
           | binopexpr6
           ;



binopexpr6 : binopexpr6 OPNAME6 binopexpr7
           | binopexpr7
           ;



binopexpr7 : binopexpr7 OPNAME7 smallexpr
           | smallexpr
           ;

*/
           
           
           /*E√êA*/

binopexpr : binopexpr op smallexpr { $$ = new Object[]{"CALL", $2, new Object[]{$1, $2}}}
          | smallexpr              { $$ = $1}
          ;


op : OPNAME1 | OPNAME2 | OPNAME3 | OPNAME4 | OPNAME5 | OPNAME6 | OPNAME7 ;



smallexpr : NAME '(' args ')'      { $$ = new Object[]{"CALL", $1, $3}; }
          | WHILE '(' expr ')' body  { $$ = new Object[]{"WHILE", $3, $5}; }
          | ifexpr                   { $$ = $1; }
          | LITERAL
          | op smallexpr
          | '(' expr ')'
          ;



args : nonemptyargs
     | 
     ;



nonemptyargs : nonemptyargs ',' expr
             | expr
             ;



ifexpr : IF '(' expr ')' body elsif else { $$ = }
       ;



elsif : ELSIF '(' expr ')' body elsif
      |
      ;



else : ELSE body
     |
     ;



body : '{' expressions '}'


%%

private ExprLexer lexer;

private int yylex()
{
	int yyl_return = -1;
	try
	{
		yylval = new ExprParserVal(0);
		yyl_return = lexer.yylex();
	}
	catch (IOException e)
	{
		System.err.println("IO error: "+e);
	}
	return yyl_return;
}

public void yyerror( String error )
{
	System.err.println("Error: "+error);
	System.exit(1);
}

public ExprParser( Reader r )
{
	lexer = new ExprLexer(r,this);
}

public static void main( String args[] ) throws IOException
{
	ExprParser yyparser = new ExprParser(new StringReader(args[0]));
	yyparser.yyparse();
}




          
           